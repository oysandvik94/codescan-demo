# 签名

## 开发中的appKey,appSecret到底是什么
+ appKey：公钥
~~~
调用服务所需要的公钥。是调用方的身份认证标识，用于调用平台可用服务
~~~
+ appSecret：私钥
~~~
签名的密钥，是跟appKey配套使用的可以简单理解成是密码
~~~

## 一.签名流程
整体流程如下:
+ 验证请求头参(appKey,timeStamp,nonce)与签名的必传参数(sign)
+ 除去sign本身，以及值是空的参数
+ 获取请求头参数，请求数据，把这些值放入SortMap中进行key值正序排序
+ 对SortMap里面的值进行拼接
+ 对拼接的值进行加密，生成签名sign，然后转成大写,作为最终签名sign
+ 把后台生成的签名sign和调用方传入的签名sign进行比较，如果不相同就返回错误(抛出异常)

## 二.签名规则
+ 1.分配appKey(标识)和appSecret(密钥)
~~~
线下生成,appKey是全局唯一的，应用appId，密钥appSecret需要高度保密。
~~~

+ 2.加入timeStamp（时间戳），以服务端当前时间为准，单位为ms ，5分钟内数据有效,可配置阈值
~~~
时间戳的目的就是为了减轻DOS攻击。防止请求被拦截后一直尝试请求接口。服务器端设置时间戳阀值，
如果(服务器时间) - (请求时间戳) 超过阀值，表示签名超时，接口调用失败。
~~~

+ 3.加入临时流水号nonce，至少为10位(20位) ，有效期内防重复提交
~~~
随机值nonce主要是为了增加签名sign的多变性，也可以保护接口的幂等性，相邻的两次请求nonce不允许重复，如果重复则认为是重复提交，接口调用失败。
1.针对查询接口，流水号只用于日志落地，便于后期日志核查。
2.针对重要类接口需校验流水号在有效期内的唯一性，以避免重复请求
~~~

~~~
通过在接口签名请求参数加上 时间戳timeStamp + 随机数nonce 可以防止 ”重放攻击“
(1).时间戳（timeStamp）:  
  以服务端当前时间为准，服务端要求客户端发过来的时间戳，必须是最近60秒内（假设值，自己定义）的。
  这样，即使这个请求即使被截取了，也只能在60s内进行重放攻击。
(2).随机数（nonce）: 
   但是，即使设置了时间戳，攻击者还有60s的攻击时间呢！
   所以需要在客户端请求中再加上一个随机数（中间黑客不可能自己修改随机数，因为有参数签名的校验呢），
   服务端会对一分钟内请求的随机数进行检查，如果有两个相同的，基本可以判定为重放攻击。
   因为正常情况下，在短时间内（比如60s）连续生成两个相同nonce的情况几乎为0

服务端“第一次”在接收到这个nonce的时候做下面行为：
  (1).去redis中查找是否有key为nonce:{nonce}的数据
  (2).如果没有，则创建这个key，把这个key失效的时间和验证timestamp失效的时间一致，比如是60s。
  (3).如果有，说明这个key在60s内已经被使用了，那么这个请求就可以判断为重放请求。
~~~

+ 4.加入签名字段sign，获取调用方传递的签名信息
~~~
通过在接口签名请求参数加上 时间戳appKey + sign解决身份验证和防止 ”参数篡改“
1.请求携带参数appKey和sign，只有拥有合法的身份appKey和正确的签名sign才能放行。解决了身份验证和参数篡改问题。
2.即使请求参数被劫持，由于获取不到appSecret（仅作本地加密使用，不参与网络传输，h5代码可以混淆加密保存），也无法伪造合法的请求。
~~~
以上字段放在请求头中

## 三.签名的生成
### 签名signature字段生成规则
~~~

鉴权参数 = 请求头签名参数(appKey,timeStamp,nonce,sign) + 请求Request参数(针对是Get请求时) + 请求Body(非针对是Get请求时 ,如Post请求)
~~~
+ (1).除去sign本身，以及值是空的参数
+ (2).先将鉴权参数以key-value的格式存储，并以key值正序排序，进行拼接 如: key1=value1&key2=value2
+ (3).最后将上面拼接的字符串在拼接应用密钥appSecret，如: key1=value1&key2=value2 + appSecret
+ (4).然后做Md5不可逆加密Md5(key1=value1&key2=value2 + appSecret) 得到的字符串作为签名signature,

### 请求参数描述
#### 请求头
~~~
请求头="appKey=xxxx&nonce=xxxx&timeStamp=xxxx&sign=xxx"
~~~
请求头中的4个参数是必须要传的，否则直接报异常

#### 请求数据
请求数据的拼接规则
+ form：按照key的字典顺序排序，将所有key=value进行拼接
~~~
表示为 表单请求时携带的数据，
~~~
+ body:
~~~
表示是一个raw数据请求（纯字符串格式），比如json的方式传递
(1).json: 按照key的字典顺序排序，将所有key=value进行拼接
例如：{“a”:“a”,“c”:“c”}   =>   a=a&c=c
(2).string: 整个字符串作为一个拼接
~~~
不同的数据格式则按照query、body的顺序进行拼接，得到所有数据最终的拼接值

